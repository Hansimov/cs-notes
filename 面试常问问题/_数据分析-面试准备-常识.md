## HTTP vs HTTPS

* 十分钟搞懂 HTTP 和 HTTPS 协议？ - 知乎 
    * https：//zhuanlan.zhihu.com/p/72616216

* HTTP 和 HTTPS 协议，看一篇就够了_不一样的博客 - CSDN 博客 
    * https：//blog.csdn.net/xiaoming100001/article/details/81109617


HTTP 超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于 TCP/IP 协议传输数据，互联网上应用最为广泛的一种网络协议，所有的 WWW 文件都必须遵守这个标准。设计 HTTP 的初衷是为了提供一种发布和接收 HTML 页面的方法。
HTTP 是一个基于 TCP/IP 通信协议来传递数据的协议，传输的数据类型为 HTML 文件、图片、查询结果等。
HTTP 协议一般用于 B/S 架构。浏览器作为 HTTP 客户端通过 URL 向 HTTP 服务端即 WEB 服务器发送所有请求。

特点：
1、客户端 / 服务端模式，请求 / 响应模式
2、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST。
3、灵活：HTTP 允许传输任意类型的数据对象。传输的类型由 Content-Type 加以标记。
4、无连接：限制每次连接只处理一个请求。服务器处理完请求，并收到客户的应答后，即断开连接，但是却不利于客户端与服务器保持会话连接，为了弥补这种不足，产生了两项记录 http 状态的技术，一个叫做 Cookie，一个叫做 Session。
5、无状态：无状态是指协议对于（客户端）事务处理没有记忆，后续处理需要前面的信息，则必须重传。
6、通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性


URI：Uniform Resource Identifier，统一资源标识符
URL：Uniform Resource Location，统一资源定位符

HTTP 使用统一资源标识符 URI 来传输数据和建立连接。

URI 是用来标示一个具体的资源的，我们可以通过 URI 知道一个资源是什么。
URL 则是用来定位具体的资源的，标示了一个具体的资源位置。互联网上的每个文件都有一个唯一的 URL。

HTTP 报文
1、请求行：包括请求方法、URL、协议 / 版本
2、请求头（Request Header）
3、请求正文

响应报文构成
1、状态行
2、响应头
3、响应正文

常见请求方法
1、GET：请求指定的页面信息，并返回实体主体。
2、POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和 / 或已有资源的修改。
3、HEAD：类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头
4、PUT：从客户端向服务器传送的数据取代指定的文档的内容。
5、DELETE：请求服务器删除指定的页面。

post 和 get 的区别：
1、都包含请求头请求行，post 多了请求 body。
2、get 多用来查询，请求参数放在 url 中，不会对服务器上的内容产生作用。post 用来提交，如把账号密码放入 body 中。
3、GET 是直接添加到 URL 后面的，直接就可以在 URL 中看到内容，而 POST 是放在报文内部的，用户无法直接看到。
4、GET 提交的数据长度是有限制的，因为 URL 长度有限制，具体的长度限制视浏览器而定。而 POST 没有。


响应状态码
访问一个网页时，浏览器会向 web 服务器发出请求。此网页所在的服务器会返回一个包含 HTTP 状态码的信息头用以响应浏览器的请求。

状态码分类
1XX- 信息型，服务器收到请求，需要请求者继续操作。
2XX- 成功型，请求成功收到，理解并处理。
3XX - 重定向，需要进一步的操作以完成请求。
4XX - 客户端错误，请求包含语法错误或无法完成请求。
5XX - 服务器错误，服务器在处理请求的过程中发生了错误。

常见状态码：
200 OK - 客户端请求成功
301 - 资源（网页等）被永久转移到其它 URL
302 - 临时跳转
400 Bad Request - 客户端请求有语法错误，不能被服务器所理解
401 Unauthorized - 请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用
404 - 请求资源不存在，可能是输入了错误的 URL
500 - 服务器内部发生了不可预期的错误
503 Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。

为什么要用 https？
实际使用中，绝大多数的网站现在都采用的是 https 协议。
HTTP 的账号密码都是明文传输，这样客户端发出的请求很容易被不法分子截取利用，因此，HTTP 协议不适合传输一些敏感信息，使用 http 协议传输隐私信息非常不安全。

一般 http 中存在如下问题：
1、请求信息明文传输，容易被窃听截取
2、数据的完整性未校验，容易被篡改
3、没有验证对方身份，存在冒充危险

为了解决上述 HTTP 存在的问题，就用到了 HTTPS。
HTTPS 协议（HyperText Transfer Protocol over Secure Socket Layer）：一般理解为 HTTP + SSL/TLS，通过 SSL 证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。
HTTPS 是身披 SSL 外壳的 HTTP，主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。

HTTPS 有如下特点：
1、内容加密：采用混合加密技术，中间者无法直接查看明文内容
2、验证身份：通过证书认证客户端访问的是自己的服务器
    - 收方能够证实发送方的真实身份
3、保护数据完整性：防止传输的内容被中间人冒充或者篡改
    - 发送方事后不能否认所发送过的报文
    - 收方或非法者不能伪造、篡改报文

混合加密：结合非对称加密和对称加密技术。客户端使用对称加密生成密钥对传输数据进行加密，然后使用非对称加密的公钥再对秘钥进行加密，所以网络上传输的数据是被秘钥加密的密文和用公钥加密后的秘密秘钥，因此即使被黑客截取，由于没有私钥，无法获取到加密明文的秘钥，便无法获取到明文数据。

数字摘要：通过单向 hash 函数对原文进行哈希，将需加密的明文 “摘要” 成一串固定长度（如 128 bit）的密文，不同的明文摘要成的密文其结果总是不相同，同样的明文其摘要必定一致，并且即使知道了摘要也不能反推出明文。

数字签名技术：数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用。它把公钥加密技术和数字摘要结合起来，形成了实用的数字签名技术。


那么 SSL 又是什么？
SSL（Secure Socket Layer，安全套接字层）：SSL 协议位于 TCP/IP 协议与各种应用层协议之间，为数据通讯提供安全支持。
TLS（Transport Layer Security，传输层安全）：是传输层加密协议，其前身是 SSL，目前使用最广泛的是 TLS 1.1、TLS 1.2。


浏览器在使用 HTTPS 传输数据的流程是什么？
1、首先客户端通过 URL 访问服务器建立 SSL 连接。
2、服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端。
3、客户端的服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级。
4、客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站。
5、服务器利用自己的私钥解密出会话密钥。
6、服务器利用会话密钥加密与客户端之间的通信。

HTTPS 的缺点
1、HTTPS 协议多次握手，导致页面的加载时间延长近 50%；
2、HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗；
3、申请 SSL 证书需要钱，功能越强大的证书费用越高。
4、SSL 涉及到的安全算法会消耗 CPU 资源，对服务器资源消耗较大。


总结 HTTPS 和 HTTP 的区别
1、HTTPS 是 HTTP 协议的安全版本，HTTP 协议的数据传输是明文的，是不安全的，HTTPS 使用了 SSL/TLS 协议进行了加密处理。
2、http 和 https 使用连接方式不同，默认端口也不一样，http 是 80，https 是 443。


## TCP 三次握手和四次挥手

* 两张动图 - 彻底明白 TCP 的三次握手与四次挥手_qzcsu 的博客 - CSDN 博客 
    * https：//blog.csdn.net/qzcsu/article/details/72861891

* TCP 协议 · 笔试面试知识整理 
    * https：//hit-alibaba.github.io/interview/basic/network/TCP.html


TCP 把连接作为最基本的对象，每一条 TCP 连接都有两个端点，这种断点我们叫作套接字（socket），它的定义为端口号拼接到 IP 地址即构成了套接字。
例如，若 IP 地址为 192.3.4.16 而端口号为 80，那么得到的套接字为 192.3.4.16：80。

TCP 的特性
- TCP 提供一种面向连接的、可靠的字节流服务
- 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP
- TCP 使用校验和，确认和重传机制来保证可靠传输
- TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复
- TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制

注意：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。

TCP 报文首部
1、源端口和目的端口，各占 2 个字节，分别写入源端口和目的端口；
2、序号，占 4 个字节，TCP 连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301 ，而携带的数据共有 100 字段，显然下一个报文段（如果还有的话）的数据序号应该从 401 开始；
3、确认号，占 4 个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B 收到了 A 发送过来的报文，其序列号字段是 501，而数据长度是 200 字节，这表明 B 正确的收到了 A 发送的到序号 700 为止的数据。因此，B 期望收到 A 的下一个数据序号是 701，于是 B 在发送给 A 的确认报文段中把确认号置为 701；
4、数据偏移，占 4 位，它指出 TCP 报文的数据距离 TCP 报文段的起始处有多远；
5、保留，占 6 位，保留今后使用，但目前应都为 0；
6、紧急 URG，当 URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；
7、确认 ACK，仅当 ACK=1 时，确认号字段才有效。TCP 规定，在连接建立后所有报文的传输都必须把 ACK 置 1；
8、推送 PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将 PSH=1；
9、复位 RST，当 RST=1，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立连接；
10、同步 SYN，在连接建立时用来同步序号。当 SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使 SYN=1，ACK=1；
11、终止 FIN，用来释放连接。当 FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；
12、窗口，占 2 字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；
13、检验和，占 2 字节，校验首部和数据这两部分；
14、紧急指针，占 2 字节，指出本报文段中的紧急数据的字节数；
15、选项，长度可变，定义一些其他的可选的参数。


TCP 的三次握手
所谓三次握手（Three-way Handshake），是指建立一个 TCP 连接时，需要客户端和服务器总共发送 3 个包。
三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行 connect（） 时。将触发三次握手。

1、第一次握手（SYN=1， seq=x）：
客户端发送一个 TCP 的 SYN 标志位置 1 的包，指明客户端打算连接的服务器的端口，以及初始序号 X，保存在包头的序列号（Sequence Number）字段里。
发送完毕后，客户端进入 SYN_SENT 状态。

2、第二次握手（SYN=1， ACK=1， seq=y， ACKnum=x+1）：
服务器发回确认包（ACK）应答。即 SYN 标志位和 ACK 标志位均为 1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号（Acknowledgement Number）设置为客户的 ISN 加 1，即 X+1。
发送完毕后，服务器端进入 SYN_RCVD 状态。

3、第三次握手（ACK=1，ACKnum=y+1）
客户端再次发送确认包（ACK），SYN 标志位为 0，ACK 标志位为 1，并且把服务器发来 ACK 的序号字段 + 1，放在确定字段中发送给对方，并且在数据段放写 ISN 的 + 1
发送完毕后，客户端进入 ESTABLISHED 状态。
当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。

TCP 连接的建立（三次握手）
0、最开始的时候客户端和服务器都是处于 CLOSED 状态。主动打开连接的为客户端，被动打开连接的是服务器。
1、TCP 服务器进程先创建传输控制块 TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 LISTEN（监听）状态；
2、TCP 客户进程也是先创建传输控制块 TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位 SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP 客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP 规定，SYN 报文段（SYN=1 的报文段）不能携带数据，但需要消耗掉一个序号。
3、TCP 服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是 ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP 服务器进程进入了 SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。
4、TCP 客户进程收到确认后，还要向服务器给出确认。确认报文的 ACK=1，ack=y+1，自己的序列号 seq=x+1，此时，TCP 连接建立，客户端进入 ESTABLISHED（已建立连接）状态。TCP 规定，ACK 报文段可以携带数据，但是如果不携带数据则不消耗序号。
5、当服务器收到客户端的确认后也进入 ESTABLISHED 状态，此后双方就可以开始通信了。

为什么 TCP 客户端最后还要发送一次确认呢？
一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于 TCP 的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。
此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。


TCP 四次挥手
TCP 的连接的拆除需要发送四个包，因此称为四次挥手（Four-way handshake），也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close（） 操作即可产生挥手操作。

1、第一次挥手（FIN=1，seq=x）
假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。
发送完毕后，客户端进入 FIN_WAIT_1 状态。

2、第二次挥手（ACK=1，ACKnum=x+1）
服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。
发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。

3、第三次挥手（FIN=1，seq=y）
服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为 1。
发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个 ACK。

4、第四次挥手（ACK=1，ACKnum=y+1）
客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。
服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。
客户端等待了某个固定时间（两个最大段生命周期，2 MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。

TCP 连接的释放（四次挥手）
数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于 ESTABLISHED 状态，然后客户端主动关闭，服务器被动关闭。

1、客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为 seq=u（等于前面已经传送过来的数据的最后一个字节的序号加 1），此时，客户端进入 FIN-WAIT-1（终止等待 1）状态。 TCP 规定，FIN 报文段即使不携带数据，也要消耗一个序号。
2、服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号 seq=v，此时，服务端就进入了 CLOSE-WAIT（关闭等待）状态。TCP 服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。
3、客户端收到服务器的确认请求后，此时，客户端就进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4、服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 seq=w，此时，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。
5、客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态。注意此时 TCP 连接还没有释放，必须经过 2*MSL（最长报文段寿命）的时间后，当客户端撤销相应的 TCB 后，才进入 CLOSED 状态。
6、服务器只要收到了客户端发出的确认，立即进入 CLOSED 状态。同样，撤销 TCB 后，就结束了这次的 TCP 连接。可以看到，服务器结束 TCP 连接的时间要比客户端早一些。



为什么客户端最后还要等待 2 MSL？
MSL（Maximum Segment Lifetime），TCP 允许不同的实现可以设置不同的 MSL 值。
第一，保证客户端发送的最后一个 ACK 报文能够到达服务器，因为这个 ACK 报文可能丢失，站在服务器的角度看来，我已经发送了 FIN+ACK 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启 2MSL 计时器。
第二，防止类似与 “三次握手” 中提到了的 “已经失效的连接请求报文段” 出现在本连接中。客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。

为什么建立连接是三次握手，关闭连接确是四次挥手呢？
建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。
而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。


如果已经建立了连接，但是客户端突然出现故障了怎么办？
TCP 还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为 2 小时，若 2 小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 75 秒发送一次。若一连发送 10 个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

TCP KeepAlive
TCP 的连接，实际上是一种纯软件层面的概念，在物理层面并没有 “连接” 这种概念。TCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制实现来实现。主流的操作系统基本都在内核里支持了这个特性。

TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。

TCP-Keepalive-HOWTO 有对 TCP KeepAlive 特性的详细介绍。
TCP KeepAlive 的局限：
首先 TCP KeepAlive 监测的方式是发送一个 probe 包，会给网络带来额外的流量，另外 TCP KeepAlive 只能在内核层级监测连接的存活与否，而连接的存活不一定代表服务的可用。例如当一个服务器 CPU 进程服务器占用达到 100%，已经卡死不能响应请求了，此时 TCP KeepAlive 依然会认为连接是存活的。因此 TCP KeepAlive 对于应用层程序的价值是相对较小的，需要做连接保活的应用层程序，例如 QQ，往往会在应用层实现自己的心跳功能。

## OSI 七层模型 和 TCP/IP 四层模型
* 一文读懂 OSI 七层模型与 TCP/IP 四层的区别 / 联系_Machine Learning with Turing's Cat-CSDN 博客 
    * https：//blog.csdn.net/qq_39521554/article/details/79894501

## TCP vs UDP
IP 层在网络层，可以实现两个主机之间的通信。但是这并不具体，因为真正进行通信的实体是在主机中的进程，是一个主机中的一个进程与另外一个主机中的一个进程在交换数据。IP 协议虽然能把数据报文送到目的主机，但是并没有交付给主机的具体应用进程。而端到端的通信才应该是应用进程之间的通信。

UDP，在传送数据前不需要先建立连接，远地的主机在收到 UDP 报文后也不需要给出任何确认。虽然 UDP 不提供可靠交付，但是正是因为这样，省去和很多的开销，使得它的速度比较快，比如一些对实时性要求较高的服务，就常常使用的是 UDP。对应的应用层的协议主要有 DNS，TFTP，DHCP，SNMP，NFS 等。

TCP，提供面向连接的服务，在传送数据之前必须先建立连接，数据传送完成后要释放连接。因此 TCP 是一种可靠的的运输服务，但是正因为这样，不可避免的增加了许多的开销，比如确认，流量控制等。对应的应用层的协议主要有 SMTP，TELNET，HTTP，FTP 等。

## 进程 vs 线程

* 《现代操作系统》 第 2 章

* 操作系统 - 小土刀的面试刷题笔记 
    * https：//wdxtub.com/interview/14520847747820.html

* 进程和线程的区别是什么？__牛客网 
    * https：//www.nowcoder.com/questionTerminal/234895a70e0b40e19db7f3fbaabc5fa3

* 面试总结，多进程和多线程的区别_CSDN-CSDN 博客 
    * https：//blog.csdn.net/linraise/article/details/12979473

一个进程就是一个正在执行程序的实例。
在传统操作系统中，每个进程有一个地址空间和一个控制线程。
进程是资源分配的最小单位，线程是 CPU 调度的最小单位

进程和线程的区别：
1、进程是运行中的程序，线程是进程的内部的一个执行序列
2、进程是资源分配的单元，线程是执行的单元
3、进程间切换代价大，线程间切换代价小
4、进程拥有资源多，线程拥有资源少
5、多个线程共享进程的资源

进程和线程的区别：
a、地址空间和其它资源：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。
b、通信：进程间通信 IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。
c、调度和切换：线程上下文切换比进程上下文切换要快得多。
d、在多线程 OS 中，进程不是一个可执行的实体。

从概念上：
- 进程：一个程序对一个数据集的动态执行过程，是分配资源的基本单位。
- 线程：一个进程内的基本调度单位。线程的划分尺度小于进程，一个进程包含一个或者更多的线程。
从执行过程中来看：
- 进程：拥有独立的内存单元，而多个线程共享内存，从而提高了应用程序的运行效率。
- 线程：每一个独立的线程，都有一个程序运行的入口、顺序执行序列、和程序的出口。但是线程不能够独立的执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
从逻辑角度来看（重要区别）：
- 多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但是，操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理及资源分配。

个人总结：
1、进程是正在运行的程序，而线程则是进程中的一个执行序列。
2、进程和线程的核心区别在于地址空间和资源。进程是资源分配的单元，线程是执行的单元。
3、不同进程拥有独立的地址空间和资源，而同一进程中的线程则共享地址空间和进程中的资源。
4、进程拥有的资源多，线程拥有的少；进程的上下文切换代价大，线程的代价小。

协程，又称微线程，纤程。英文名 Coroutine。

协程可以理解为用户级线程，协程和线程的区别是：
线程是抢占式的调度，而协程是协同式的调度，协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多 CPU 的能力。

### 多进程 vs 多线程

* 多进程和多线程的概念 - fengMisaka - 博客园 
    * https：//www.cnblogs.com/linuxAndMcu/p/11064916.html

* 一文看懂 Python 多进程与多线程编程（工作学习面试必读） - 知乎 
    * https：//zhuanlan.zhihu.com/p/46368084

多线程是什么？
进程可以简单的理解为一个可以独立运行的程序单位，它是线程的集合，进程就是有一个或多个线程构成的。而线程是进程中的实际运行单位，是操作系统进行运算调度的最小单位。可理解为线程是进程中的一个最小运行单元。
那么多线程就很容易理解：多线程就是指一个进程中同时有多个线程正在执行。

为什么要使用多线程？
- 在一个程序中，有很多的操作是非常耗时的，如数据库读写操作、IO 操作等，如果使用单线程，那么程序就必须等待这些操作执行完成之后才能执行其他操作。使用多线程，可以在将耗时任务放在后台继续执行的同时，同时执行其他操作。
- 可以提高程序的效率。
- 在一些等待的任务上，如用户输入，文件读取等，多线程就非常有用了。

多线程的缺点：
- 使用太多线程，是很耗系统资源，因为线程需要开辟内存。更多线程需要更多内存。
- 影响系统性能，因为操作系统需要在线程之间来回切换。
- 需要考虑线程操作对程序的影响，如线程挂起，中止等操作对程序的影响。
- 线程使用不当会发生很多问题。

总结：多线程是异步的，但这不代表多线程真的是几个线程是在同时进行，实际上是系统不断地在各个线程之间来回的切换（因为系统切换的速度非常的快，所以给我们在同时运行的错觉）。


多进程是什么？
进程是程序在计算机上的一次执行活动。当你运行一个程序，你就启动了一个进程。凡是用于完成操作系统的各种功能的进程就是系统进程，而所有由你启动的进程都是用户进程。
同理，多进程就是指计算机同时执行多个进程，一般是同时运行多个软件。


多线程与多进程，选择谁？

知乎有一个通俗的比方。
- 单进程单线程：一个人在一个桌子上吃菜。
- 单进程多线程：多个人在同一个桌子上一起吃菜。
- 多进程单线程：多个人每个人在自己的桌子上吃菜。

多线程的问题是，资源共享会发生冲突争抢。

1、对于 Windows 系统来说，【开桌子】的开销很大，因此 Windows 鼓励大家在一个桌子上吃菜。因此 Windows 多线程学习重点是要大量面对资源争抢与同步方面的问题。
也就是说，Windows 鼓励多线程，但是要解决资源抢夺和同步问题。
2、对于 Linux 系统来说，【开桌子】的开销很小，因此 Linux 鼓励大家尽量每个人都开自己的桌子吃菜。这带来新的问题是：坐在两张不
同的桌子上，说话不方便。因此，Linux 下的学习重点大家要学习进程间通信的方法。
也就是说，Linux 鼓励多进程，但是要解决进程间通信的问题。

开销这里主要指的是时间开销。
可以做个实验：创建一个进程，在进程中往内存写若干数据，然后读出该数据，然后退出。此过程重复 1000 次，相当于创建 / 销毁进程 1000 次。在我机器上的测试结果是：
- Ubuntu ：耗时 0.8 秒
- Windows 7：耗时 79.8 秒。
两者开销大约相差一百倍。

这意味着，在 Windows 中，进程创建的开销不容忽视。换句话说就是，Windows 编程中不建议你创建进程，如果你的程序架构需要大量创建进程，那么最好是切换到 Linux 系统。

大量创建进程的典型例子有两个，一个是 gnu autotools 工具链，用于编译很多开源代码的，他们在 Windows 下编译速度会很慢，因此软件开发人员最好是避免使用 Windows。另一个是服务器，某些服务器框架依靠大量创建进程来干活，甚至是对每个用户请求就创建一个进程，这些服务器在 Windows 下运行的效率就会很差。这 "可能' 也是放眼全世界范围，Linux 服务器远远多于 Windows 服务器的原因。

如果你是写服务器端应用的，其实在现在的网络服务模型下，开新进程的开销是可以忽略不计的，因为现在一般流行的是按照 CPU 核心数量开进程或者线程，开完之后在数量上一直保持，进程与线程内部使用协程或者异步通信来处理多个并发连接，因而开进程与开线程的开销可以忽略了。

另外一种新的开销被提上日程：核心切换开销。现代的体系，一般 CPU 会有多个核心，而多个核心可以同时运行多个不同的线程或者进程。当每个 CPU 核心运行一个进程的时候，由于每个进程的资源都独立，所以 CPU 核心之间切换的时候无需考虑上下文。
当每个 CPU 核心运行一个线程的时候，由于每个线程需要共享资源，所以这些资源必须从 CPU 的一个核心被复制到另外一个核心，才能继续运算，这占用了额外的开销。换句话说，在 CPU 为多核的情况下，多线程在性能上不如多进程。
因而，当前面向多核的服务器端编程中，需要习惯多进程而非多线程。


由于 GIL 的存在，很多人认为 Python 多进程编程更快，针对多核 CPU，理论上来说也是采用多进程更能有效利用资源。网上很多人已做过比较，我直接告诉你结论吧。

- 对 CPU 密集型代码（比如循环计算）：多进程效率更高
- 对 IO 密集型代码（比如文件操作，网络爬虫）：多线程效率更高。

为什么是这样呢？其实也不难理解。对于 IO 密集型操作，大部分消耗时间其实是等待时间，在等待时间中 CPU 是不需要工作的，那你在此期间提供双 CPU 资源也是利用不上的，相反对于 CPU 密集型代码，2 个 CPU 干活肯定比一个 CPU 快很多。那么为什么多线程会对 IO 密集型代码有用呢？这时因为 python 碰到等待会释放 GIL 供新的线程使用，实现了线程间的切换。

并行、并发、高并发等概念
并行：多个 CPU 实例或多台机器同时执行一段处理逻辑，是真正的同时。
并发：通过 CPU 调度算法，让用户看上去同时执行，实际上 CPU 操作层面不是真正的同时。

并发时如果操作了公用资源，可能产生线程安全问题。
- 线程安全：多个线程操作公用资源，有可能产生安全问题。
- 高并发：高并发指的是是一种系统运行过程中遇到的一种 “短时间内遇到大量操作请求” 的情况，主要发生在 web 系统集中大量访问或者 socket 端口集中性收到大量请求（例如： 12306 的抢票情况；天猫双十一活动）。
该情况的发生会导致系统在这段时间内执行大量操作，例如对资源的请求，数据库的操作等。如果高并发处理不好，不仅仅降低了用户的体验度（请求响应时间过长），同时可能导致系统宕机，严重的甚至导致 OOM 异常，系统停止工作等。如果要想系统能够适应高并发状态，则需要从各个方面进行系统优化，包括，硬件、网络、系统架构、开发语言的选取、数据结构的运用、算法优化、数据库优化……。

多线程与高并发的联系
多线程只是在同步或异步角度上解决高并发问题的其中的一个方法手段，是在同一时刻利用计算机闲置资源的一种方式
多线程在高并发问题中的作用就是充分利用计算机资源，使计算机的资源在每一时刻都能达到最大的利用率，不至于浪费计算机资源使其闲置。


## 进程间通信 vs 线程间通信

* 进程间通信的方式——信号、管道、消息队列、共享内存 - 0giant - 博客园 
    * https：//www.cnblogs.com/luo77/p/5816326.html

* 面试/笔试第二弹 —— 操作系统面试问题集锦_Rico's Blogs-CSDN博客 
    * https://blog.csdn.net/justloveyou_/article/details/78304294

* 进程间通信 IPC （InterProcess Communication） - 简书 
    * https：//www.jianshu.com/p/c1015f5ffa74

* 进程间 8 种通信方式详解_在努力！-CSDN 博客 
    * https：//blog.csdn.net/violet_echo_0908/article/details/51201278


进程间通信的方式——信号、管道、消息队列、共享内存

多进程：
首先，先来讲一下 fork 之后，发生了什么事情。
> 由 fork 创建的新进程被称为子进程（child process）。该函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是 0，而父进程的返回值则是新进程（子进程）的进程 id。将子进程 id 返回给父进程的理由是：因为一个进程的子进程可以多于一个，没有一个函数使一个进程可以获得其所有子进程的进程 id。对子进程来说，之所以 fork 返回 0 给它，是因为它随时可以调用 getpid（） 来获取自己的 pid；也可以调用 getppid（） 来获取父进程的 id。（进程 id 0 总是由交换进程使用，所以一个子进程的进程 id 不可能为 0 ）。
> fork 之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这 2 个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置（两进程的程序计数器 pc 值相同，也就是说，子进程是从 fork 返回处开始执行的），但有一点不同，如果 fork 成功，子进程中 fork 的返回值是 0，父进程中 fork 的返回值是子进程的进程号，如果 fork 不成功，父进程会返回错误。
> 可以这样想象，2 个进程一直同时运行，而且步调一致，在 fork 之后，他们分别做不同的工作，也就是分岔了。这也是 fork 为什么叫 fork 的原因。
> 至于那一个最先运行，可能与操作系统（调度算法）有关，而且这个问题在实际应用中并不重要，如果需要父子进程协同，可以通过原语的办法解决。

常见的通信方式：
1. （匿名）管道 pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。
2. 有名管道 FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。
3. 高级管道 popen：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。
4. 消息队列 Message Queue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。
5. 共享存储 Shared Memory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。
6. 信号量 Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。
7. 套接字 Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。
8. 信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。


进程间通信的概念
每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程 1 把数据从用户空间拷到内核缓冲区，进程 2 再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。


进程间通信的 7 种方式

第一类：传统的 Unix 通信机制

1. 管道 / 匿名管道（pipe）
- 管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。
- 只能用于父子进程或者兄弟进程之间（具有亲缘关系的进程）；
- 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。
- 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出。写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。

管道的实质：
管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。
该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。
当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。

管道的主要局限性，正体现在它的特点上：
- 只支持单向数据流；
- 只能用于具有亲缘关系的进程之间；
- 没有名字；
- 管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）；
- 管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；

2. 有名管道（FIFO）
匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道（FIFO）。
有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循先进先出（first in first out），对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如 lseek（）等文件定位操作。有名管道的名字存在于文件系统中，内容存放在内存中。

匿名管道和有名管道总结：
（1）管道是特殊类型的文件，在满足先入先出的原则条件下可以进行读写，但不能进行定位读写。
（2）匿名管道是单向的，只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
（3）无名管道阻塞问题：无名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。
（4）有名管道阻塞问题：有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。


### 线程池

### 死锁的必要条件和解决

## 进程的状态

## 进程/线程同步

## 进程调度

## 分页和分段

## 页面置换算法

### MapReduce 全过程
分片怎么读的，为什么用快排，换别的行不行，多路归并怎么实现的，环形缓冲区怎么实现的。

### 快排、二分算法

## 飞速过掉剑指 + SQL


### 哈希表的原理
key-value
哈希表是链表和数组的优点集合

## B + 树、红黑树

## B + 树如何提高检索效率？（数据存放在叶子节点，和 B 树做对比）

### 数据库如何提高检索效率
索引 + 缓存


## UDF HDFS

## 抖音推荐算法